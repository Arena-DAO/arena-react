/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Uint128, DaoConfigForUint64, Duration, Threshold, PercentageThreshold, Decimal, EntryStatus, ApplicantStatus, Action, Expiration, Timestamp, Uint64, QueryMsg, Addr, ApplicantResponse, TeamEntryResponse, ArrayOfApplicantResponse, ArrayOfTeamEntryResponse, ArrayOfAddr, OwnershipForString } from "./ArenaTeamEnrollments.types";
export interface ArenaTeamEnrollmentsReadOnlyInterface {
  contractAddress: string;
  getEntry: ({
    entryId
  }: {
    entryId: number;
  }) => Promise<TeamEntryResponse>;
  listEntries: ({
    categoryId,
    limit,
    startAfter,
    status
  }: {
    categoryId?: Uint128;
    limit?: number;
    startAfter?: number;
    status?: EntryStatus;
  }) => Promise<ArrayOfTeamEntryResponse>;
  getApplicant: ({
    applicant,
    entryId
  }: {
    applicant: string;
    entryId: number;
  }) => Promise<ApplicantResponse>;
  listApplicants: ({
    entryId,
    limit,
    startAfter
  }: {
    entryId: number;
    limit?: number;
    startAfter?: string;
  }) => Promise<ArrayOfApplicantResponse>;
  listTeams: ({
    limit,
    startAfter,
    user
  }: {
    limit?: number;
    startAfter?: string;
    user: string;
  }) => Promise<ArrayOfAddr>;
  ownership: () => Promise<OwnershipForString>;
}
export class ArenaTeamEnrollmentsQueryClient implements ArenaTeamEnrollmentsReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getEntry = this.getEntry.bind(this);
    this.listEntries = this.listEntries.bind(this);
    this.getApplicant = this.getApplicant.bind(this);
    this.listApplicants = this.listApplicants.bind(this);
    this.listTeams = this.listTeams.bind(this);
    this.ownership = this.ownership.bind(this);
  }
  getEntry = async ({
    entryId
  }: {
    entryId: number;
  }): Promise<TeamEntryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_entry: {
        entry_id: entryId
      }
    });
  };
  listEntries = async ({
    categoryId,
    limit,
    startAfter,
    status
  }: {
    categoryId?: Uint128;
    limit?: number;
    startAfter?: number;
    status?: EntryStatus;
  }): Promise<ArrayOfTeamEntryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_entries: {
        category_id: categoryId,
        limit,
        start_after: startAfter,
        status
      }
    });
  };
  getApplicant = async ({
    applicant,
    entryId
  }: {
    applicant: string;
    entryId: number;
  }): Promise<ApplicantResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_applicant: {
        applicant,
        entry_id: entryId
      }
    });
  };
  listApplicants = async ({
    entryId,
    limit,
    startAfter
  }: {
    entryId: number;
    limit?: number;
    startAfter?: string;
  }): Promise<ArrayOfApplicantResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_applicants: {
        entry_id: entryId,
        limit,
        start_after: startAfter
      }
    });
  };
  listTeams = async ({
    limit,
    startAfter,
    user
  }: {
    limit?: number;
    startAfter?: string;
    user: string;
  }): Promise<ArrayOfAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_teams: {
        limit,
        start_after: startAfter,
        user
      }
    });
  };
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {}
    });
  };
}
export interface ArenaTeamEnrollmentsInterface extends ArenaTeamEnrollmentsReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createEntry: ({
    categoryId,
    daoConfig,
    description,
    title
  }: {
    categoryId?: Uint128;
    daoConfig: DaoConfig_for_uint64;
    description: string;
    title: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateEntryStatus: ({
    entryId,
    status
  }: {
    entryId: number;
    status: EntryStatus;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  apply: ({
    entryId
  }: {
    entryId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  withdrawApplication: ({
    entryId
  }: {
    entryId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateApplicantStatus: ({
    applicant,
    entryId,
    status
  }: {
    applicant: string;
    entryId: number;
    status: ApplicantStatus;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateOwnership: (action: Action, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export class ArenaTeamEnrollmentsClient extends ArenaTeamEnrollmentsQueryClient implements ArenaTeamEnrollmentsInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createEntry = this.createEntry.bind(this);
    this.updateEntryStatus = this.updateEntryStatus.bind(this);
    this.apply = this.apply.bind(this);
    this.withdrawApplication = this.withdrawApplication.bind(this);
    this.updateApplicantStatus = this.updateApplicantStatus.bind(this);
    this.updateOwnership = this.updateOwnership.bind(this);
  }
  createEntry = async ({
    categoryId,
    daoConfig,
    description,
    title
  }: {
    categoryId?: Uint128;
    daoConfig: DaoConfig_for_uint64;
    description: string;
    title: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_entry: {
        category_id: categoryId,
        dao_config: daoConfig,
        description,
        title
      }
    }, fee_, memo_, funds_);
  };
  updateEntryStatus = async ({
    entryId,
    status
  }: {
    entryId: number;
    status: EntryStatus;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_entry_status: {
        entry_id: entryId,
        status
      }
    }, fee_, memo_, funds_);
  };
  apply = async ({
    entryId
  }: {
    entryId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      apply: {
        entry_id: entryId
      }
    }, fee_, memo_, funds_);
  };
  withdrawApplication = async ({
    entryId
  }: {
    entryId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_application: {
        entry_id: entryId
      }
    }, fee_, memo_, funds_);
  };
  updateApplicantStatus = async ({
    applicant,
    entryId,
    status
  }: {
    applicant: string;
    entryId: number;
    status: ApplicantStatus;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_applicant_status: {
        applicant,
        entry_id: entryId,
        status
      }
    }, fee_, memo_, funds_);
  };
  updateOwnership = async (action: Action, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_ownership: action
    }, fee_, memo_, funds_);
  };
}