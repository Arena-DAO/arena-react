/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, InstantiateMsg, MemberBalanceUnchecked, Cw20Coin, Cw721Collection, Coin, ExecuteMsg, Binary, Decimal, Action, Expiration, Timestamp, Uint64, Cw20ReceiveMsg, Cw721ReceiveMsg, DistributionForString, MemberPercentageForString, FeeInformationForString, TransferEscrowOwnershipMsg, QueryMsg, MigrateMsg, BalanceVerified, Addr, ArrayOfMemberBalanceChecked, MemberBalanceChecked, DumpStateResponse, Boolean, OwnershipForString } from "./ArenaTeamEnrollments.types";
import { ArenaTeamEnrollmentsQueryClient, ArenaTeamEnrollmentsClient } from "./ArenaTeamEnrollments.client";
export const arenaTeamEnrollmentsQueryKeys = {
  contract: ([{
    contract: "arenaTeamEnrollments"
  }] as const),
  address: (contractAddress: string | undefined) => ([{
    ...arenaTeamEnrollmentsQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  balances: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "balances",
    args
  }] as const),
  balance: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "balance",
    args
  }] as const),
  due: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "due",
    args
  }] as const),
  dues: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "dues",
    args
  }] as const),
  initialDues: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "initial_dues",
    args
  }] as const),
  isFunded: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "is_funded",
    args
  }] as const),
  isFullyFunded: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "is_fully_funded",
    args
  }] as const),
  totalBalance: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "total_balance",
    args
  }] as const),
  isLocked: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "is_locked",
    args
  }] as const),
  dumpState: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "dump_state",
    args
  }] as const),
  ownership: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaTeamEnrollmentsQueryKeys.address(contractAddress)[0],
    method: "ownership",
    args
  }] as const)
};
export const arenaTeamEnrollmentsQueries = {
  balances: <TData = ArrayOfMemberBalanceChecked,>({
    client,
    args,
    options
  }: ArenaTeamEnrollmentsBalancesQuery<TData>): UseQueryOptions<ArrayOfMemberBalanceChecked, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.balances(client?.contractAddress, args),
    queryFn: () => client ? client.balances({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  balance: <TData = BalanceVerified,>({
    client,
    args,
    options
  }: ArenaTeamEnrollmentsBalanceQuery<TData>): UseQueryOptions<BalanceVerified, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.balance(client?.contractAddress, args),
    queryFn: () => client ? client.balance({
      addr: args.addr
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  due: <TData = BalanceVerified,>({
    client,
    args,
    options
  }: ArenaTeamEnrollmentsDueQuery<TData>): UseQueryOptions<BalanceVerified, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.due(client?.contractAddress, args),
    queryFn: () => client ? client.due({
      addr: args.addr
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  dues: <TData = ArrayOfMemberBalanceChecked,>({
    client,
    args,
    options
  }: ArenaTeamEnrollmentsDuesQuery<TData>): UseQueryOptions<ArrayOfMemberBalanceChecked, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.dues(client?.contractAddress, args),
    queryFn: () => client ? client.dues({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  initialDues: <TData = ArrayOfMemberBalanceChecked,>({
    client,
    args,
    options
  }: ArenaTeamEnrollmentsInitialDuesQuery<TData>): UseQueryOptions<ArrayOfMemberBalanceChecked, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.initialDues(client?.contractAddress, args),
    queryFn: () => client ? client.initialDues({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  isFunded: <TData = Boolean,>({
    client,
    args,
    options
  }: ArenaTeamEnrollmentsIsFundedQuery<TData>): UseQueryOptions<Boolean, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.isFunded(client?.contractAddress, args),
    queryFn: () => client ? client.isFunded({
      addr: args.addr
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  isFullyFunded: <TData = Boolean,>({
    client,
    options
  }: ArenaTeamEnrollmentsIsFullyFundedQuery<TData>): UseQueryOptions<Boolean, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.isFullyFunded(client?.contractAddress),
    queryFn: () => client ? client.isFullyFunded() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  totalBalance: <TData = BalanceVerified,>({
    client,
    options
  }: ArenaTeamEnrollmentsTotalBalanceQuery<TData>): UseQueryOptions<BalanceVerified, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.totalBalance(client?.contractAddress),
    queryFn: () => client ? client.totalBalance() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  isLocked: <TData = Boolean,>({
    client,
    options
  }: ArenaTeamEnrollmentsIsLockedQuery<TData>): UseQueryOptions<Boolean, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.isLocked(client?.contractAddress),
    queryFn: () => client ? client.isLocked() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  dumpState: <TData = DumpStateResponse,>({
    client,
    args,
    options
  }: ArenaTeamEnrollmentsDumpStateQuery<TData>): UseQueryOptions<DumpStateResponse, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.dumpState(client?.contractAddress, args),
    queryFn: () => client ? client.dumpState({
      addr: args.addr
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  ownership: <TData = OwnershipForString,>({
    client,
    options
  }: ArenaTeamEnrollmentsOwnershipQuery<TData>): UseQueryOptions<OwnershipForString, Error, TData> => ({
    queryKey: arenaTeamEnrollmentsQueryKeys.ownership(client?.contractAddress),
    queryFn: () => client ? client.ownership() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface ArenaTeamEnrollmentsReactQuery<TResponse, TData = TResponse> {
  client: ArenaTeamEnrollmentsQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface ArenaTeamEnrollmentsOwnershipQuery<TData> extends ArenaTeamEnrollmentsReactQuery<OwnershipForString, TData> {}
export function useArenaTeamEnrollmentsOwnershipQuery<TData = OwnershipForString>({
  client,
  options
}: ArenaTeamEnrollmentsOwnershipQuery<TData>) {
  return useQuery<OwnershipForString, Error, TData>(arenaTeamEnrollmentsQueryKeys.ownership(client?.contractAddress), () => client ? client.ownership() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsDumpStateQuery<TData> extends ArenaTeamEnrollmentsReactQuery<DumpStateResponse, TData> {
  args: {
    addr?: string;
  };
}
export function useArenaTeamEnrollmentsDumpStateQuery<TData = DumpStateResponse>({
  client,
  args,
  options
}: ArenaTeamEnrollmentsDumpStateQuery<TData>) {
  return useQuery<DumpStateResponse, Error, TData>(arenaTeamEnrollmentsQueryKeys.dumpState(client?.contractAddress, args), () => client ? client.dumpState({
    addr: args.addr
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsIsLockedQuery<TData> extends ArenaTeamEnrollmentsReactQuery<Boolean, TData> {}
export function useArenaTeamEnrollmentsIsLockedQuery<TData = Boolean>({
  client,
  options
}: ArenaTeamEnrollmentsIsLockedQuery<TData>) {
  return useQuery<Boolean, Error, TData>(arenaTeamEnrollmentsQueryKeys.isLocked(client?.contractAddress), () => client ? client.isLocked() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsTotalBalanceQuery<TData> extends ArenaTeamEnrollmentsReactQuery<BalanceVerified, TData> {}
export function useArenaTeamEnrollmentsTotalBalanceQuery<TData = BalanceVerified>({
  client,
  options
}: ArenaTeamEnrollmentsTotalBalanceQuery<TData>) {
  return useQuery<BalanceVerified, Error, TData>(arenaTeamEnrollmentsQueryKeys.totalBalance(client?.contractAddress), () => client ? client.totalBalance() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsIsFullyFundedQuery<TData> extends ArenaTeamEnrollmentsReactQuery<Boolean, TData> {}
export function useArenaTeamEnrollmentsIsFullyFundedQuery<TData = Boolean>({
  client,
  options
}: ArenaTeamEnrollmentsIsFullyFundedQuery<TData>) {
  return useQuery<Boolean, Error, TData>(arenaTeamEnrollmentsQueryKeys.isFullyFunded(client?.contractAddress), () => client ? client.isFullyFunded() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsIsFundedQuery<TData> extends ArenaTeamEnrollmentsReactQuery<Boolean, TData> {
  args: {
    addr: string;
  };
}
export function useArenaTeamEnrollmentsIsFundedQuery<TData = Boolean>({
  client,
  args,
  options
}: ArenaTeamEnrollmentsIsFundedQuery<TData>) {
  return useQuery<Boolean, Error, TData>(arenaTeamEnrollmentsQueryKeys.isFunded(client?.contractAddress, args), () => client ? client.isFunded({
    addr: args.addr
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsInitialDuesQuery<TData> extends ArenaTeamEnrollmentsReactQuery<ArrayOfMemberBalanceChecked, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useArenaTeamEnrollmentsInitialDuesQuery<TData = ArrayOfMemberBalanceChecked>({
  client,
  args,
  options
}: ArenaTeamEnrollmentsInitialDuesQuery<TData>) {
  return useQuery<ArrayOfMemberBalanceChecked, Error, TData>(arenaTeamEnrollmentsQueryKeys.initialDues(client?.contractAddress, args), () => client ? client.initialDues({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsDuesQuery<TData> extends ArenaTeamEnrollmentsReactQuery<ArrayOfMemberBalanceChecked, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useArenaTeamEnrollmentsDuesQuery<TData = ArrayOfMemberBalanceChecked>({
  client,
  args,
  options
}: ArenaTeamEnrollmentsDuesQuery<TData>) {
  return useQuery<ArrayOfMemberBalanceChecked, Error, TData>(arenaTeamEnrollmentsQueryKeys.dues(client?.contractAddress, args), () => client ? client.dues({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsDueQuery<TData> extends ArenaTeamEnrollmentsReactQuery<BalanceVerified, TData> {
  args: {
    addr: string;
  };
}
export function useArenaTeamEnrollmentsDueQuery<TData = BalanceVerified>({
  client,
  args,
  options
}: ArenaTeamEnrollmentsDueQuery<TData>) {
  return useQuery<BalanceVerified, Error, TData>(arenaTeamEnrollmentsQueryKeys.due(client?.contractAddress, args), () => client ? client.due({
    addr: args.addr
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsBalanceQuery<TData> extends ArenaTeamEnrollmentsReactQuery<BalanceVerified, TData> {
  args: {
    addr: string;
  };
}
export function useArenaTeamEnrollmentsBalanceQuery<TData = BalanceVerified>({
  client,
  args,
  options
}: ArenaTeamEnrollmentsBalanceQuery<TData>) {
  return useQuery<BalanceVerified, Error, TData>(arenaTeamEnrollmentsQueryKeys.balance(client?.contractAddress, args), () => client ? client.balance({
    addr: args.addr
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsBalancesQuery<TData> extends ArenaTeamEnrollmentsReactQuery<ArrayOfMemberBalanceChecked, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useArenaTeamEnrollmentsBalancesQuery<TData = ArrayOfMemberBalanceChecked>({
  client,
  args,
  options
}: ArenaTeamEnrollmentsBalancesQuery<TData>) {
  return useQuery<ArrayOfMemberBalanceChecked, Error, TData>(arenaTeamEnrollmentsQueryKeys.balances(client?.contractAddress, args), () => client ? client.balances({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaTeamEnrollmentsUpdateOwnershipMutation {
  client: ArenaTeamEnrollmentsClient;
  msg: Action;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaTeamEnrollmentsUpdateOwnershipMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaTeamEnrollmentsUpdateOwnershipMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaTeamEnrollmentsUpdateOwnershipMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateOwnership(msg, fee, memo, funds), options);
}
export interface ArenaTeamEnrollmentsClawMutation {
  client: ArenaTeamEnrollmentsClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaTeamEnrollmentsClawMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaTeamEnrollmentsClawMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaTeamEnrollmentsClawMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.claw(fee, memo, funds), options);
}
export interface ArenaTeamEnrollmentsLockMutation {
  client: ArenaTeamEnrollmentsClient;
  msg: {
    transferOwnership?: TransferEscrowOwnershipMsg;
    value: boolean;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaTeamEnrollmentsLockMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaTeamEnrollmentsLockMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaTeamEnrollmentsLockMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.lock(msg, fee, memo, funds), options);
}
export interface ArenaTeamEnrollmentsDistributeMutation {
  client: ArenaTeamEnrollmentsClient;
  msg: {
    activationHeight?: number;
    distribution?: DistributionForString;
    groupContract: string;
    layeredFees?: FeeInformationForString[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaTeamEnrollmentsDistributeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaTeamEnrollmentsDistributeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaTeamEnrollmentsDistributeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.distribute(msg, fee, memo, funds), options);
}
export interface ArenaTeamEnrollmentsReceiveNftMutation {
  client: ArenaTeamEnrollmentsClient;
  msg: {
    msg: Binary;
    sender: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaTeamEnrollmentsReceiveNftMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaTeamEnrollmentsReceiveNftMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaTeamEnrollmentsReceiveNftMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receiveNft(msg, fee, memo, funds), options);
}
export interface ArenaTeamEnrollmentsReceiveMutation {
  client: ArenaTeamEnrollmentsClient;
  msg: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaTeamEnrollmentsReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaTeamEnrollmentsReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaTeamEnrollmentsReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receive(msg, fee, memo, funds), options);
}
export interface ArenaTeamEnrollmentsReceiveNativeMutation {
  client: ArenaTeamEnrollmentsClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaTeamEnrollmentsReceiveNativeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaTeamEnrollmentsReceiveNativeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaTeamEnrollmentsReceiveNativeMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receiveNative(fee, memo, funds), options);
}
export interface ArenaTeamEnrollmentsEnrollmentWithdrawMutation {
  client: ArenaTeamEnrollmentsClient;
  msg: {
    addrs: string[];
    entryFee: Coin;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaTeamEnrollmentsEnrollmentWithdrawMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaTeamEnrollmentsEnrollmentWithdrawMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaTeamEnrollmentsEnrollmentWithdrawMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.enrollmentWithdraw(msg, fee, memo, funds), options);
}
export interface ArenaTeamEnrollmentsWithdrawMutation {
  client: ArenaTeamEnrollmentsClient;
  msg: {
    cw20Msg?: Binary;
    cw721Msg?: Binary;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaTeamEnrollmentsWithdrawMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaTeamEnrollmentsWithdrawMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaTeamEnrollmentsWithdrawMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.withdraw(msg, fee, memo, funds), options);
}